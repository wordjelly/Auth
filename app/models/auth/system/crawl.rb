class Auth::System::Crawl

	include Mongoid::Document
	
	embedded_in :product, :class_name => Auth.configuration.product_class
	
	embeds_many :templates, :class_name => "Auth::System::Template"
	
	field :min_time_to_next_step, type: Integer
	
	field :max_time_to_next_step, type: Integer

	## to process one product.
	## how does the multiple work?
	## how many to pass into the product crawl calculation, is it directly linear, or do we have a specific function?	
	field :output, type: Array, default: []


	def calculate_duration(cart_item_ids)
		## this will depend on how long it is going to take to do this step
	end

	def generate_query_requirements(prev_crawl_input)

	end
	
	## @param[Array] prev_step_output: array of output hashes
	## @param[Array] cart_item_ids: array of cart item ids to be processed.
	## @return[Array] output : array of output hashes. Uses the templates to generate these hashes.
	def generate_output(prev_step_output,cart_item_ids=nil)
		if cart_item_ids.nil?
			prev_step_output.each do |cart_item_output|

			end
		else
			cart_item_ids.each do |cid|
				output_hash = {}
				## each template is for one product id.
				## and inside summate it can crosses the individual products to do the summation.
				self.templates.each_with_index {|template,key|
					if template.summate
						template.summate_items(key,output_hash)
					else
						template.add_item_to_output_hash(key,output_hash) 
					end
				}
				self.output << output_hash
			end
		end
	end

end

=begin
ARCHITECTURE :

1.First embedded crawls inside products
2.Each product thus has an array of crawls. These are basically the individual sop's that have to be done for the product.

3.Inside each crawl embedded many templates.
4.Inside each crawl is also a field called "output" : this is an array. 5.Each element in this array stores the output generated by passing each of the prodcuts through the template array in the crawl.
6.The idea is that the template defines what is output from the crawl, if one single product is to be processed.

7.How does the templating work
8.Imagine, 3 products have to be processed.
So we start with an array of 3 products :
[c_item1,c_item2,c_item3]

Now we pass each item to the whole array of templates.
For each item we initialize a hash called an output hash.
Then we see if the template has summate on or off.

## => if summate is off : it adds an entry to the output_hash, with the key as the product_id_to_generate from the template, and the value as a hash.
## this contains the template_id itself, the from(this will be the same as the start_amount described below), the to(this will be the from + the amount_generated), the original_template_id : the same as the template_id, (in case of summate this is maintained, so that we can keep a track of the original id.)
## so now we add this to the output_hash, if the hash already contains the product_id, then we just append this hash to that key.

## => If summate is on, we call template.summate
this function will basically look in all the output hashes(it iterates #output mentionedin point 2 in reverse.).
For each template we have stored the following three attributes :
1. summate_index : the index of the template with which we have to try to summate this from the previous product output hashes.
2. summate : true /false
3. create_new_item_if_amount_crosses : the amount that if crossed,in a given products template, then we wont just summate, but instead we will create a new product.

SO how summate works is like this, 
if the template says summate, it looks in the output hash of the previous product.
there it first takes the product_to_be_generated key, and then in that it will look inside each template, if the template index matches, whatever has been defined in summate_indx, then it will try to summate with that. so there what it will do is take the from and to, and then take the amount to be added, if after adding to the to, it crosses the (3) defined above, we will then have to create a new template, othewise, we will use the template id of the template into which this was fused, and add that to the output hash. If you use the template id of a previous template(i.e from another product), then you have to set the original_template_id to whatever is the current template that you are making. That brings out another TODO: i.e the template ids will remain the same for each product passed, through, and these need to be changed.

Eg:
Product : {
	Crawls : [
		{
			templates : [
				{
					:product_id_to_generate => the id of the product that is to be generated, eg: red tube,
					:amount_generated => How much of this product is to be generated, eg 2ml,
					:start_amount => what does the product start with, eg: 0 ml,
					:summate => whether we should try to summate, for eg if a previous product ,
					:summate_with_index: ,
					:create_new_item_if_amount_crosses: ,
				}
			]		
		},
		{
	
		}
	]
}


=end