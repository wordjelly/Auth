assembly =>
[
	stages => [
		sops => [
			product_ids => [
				
			]
			entry_code => only one entry code, 
			most_probable_exit_code =>  to help the scheduler decide which exit code to pick.
			product_arrays => [
				{
					time_added :
					product_ids_added : [],
					product_ids_removed : []
				}
			],
			steps => [
				step => {
					checked_in : {
						time :
						location :
						actor :
					},
					started : {
						time : 
						location :
						actor :
					},
					ended : {
						time :
						location :
						actor : 
					},
					## or should that be called on update?
					performable_product_ids : [],
					exit_code : can output an exit code, if no exit code, then goes to next step, last step has to have an exit code.
					expected_duration: in mins
					requirements: [
						requirement: {
							state_definition: {

							},
							outputs: [
								{

								}
							],
							requirement_reference_id :	
						}
					],
					instructions: [
						## all instructions have to be given considering multiple numbers of the 
						{
							pool requirement 1
							pool requirement 2.
							mix
						}
					],
					process_step : function(args(hash with any varibles needed to do this step, or the generic hash of variables passed in.)) -> 

					basically just compare states for every single requirement, vis-a-vis its previous requirement id.

					what if we want to do something with some other variables?
				}
			]
		]
	]
]



------------------------------------------------------------


cart_items =>

--------------------------------------------------------------
transit_object => keeps a track of all the states

1> searching for applicable_sops -> if completed, then should have the applicable sops here, otherwise will go back to that.

2> adding to applicable_sops -> after adding to each sop should note success/failure.

3> 
--------------------------------------------------------------

clones assembly =>

search for those sops which are applicable to the product_ids => 

now build an order object =>

now create it into the first applicable sop => 

validates that the sop can process it =>

calls method process_step =>

calls sufficient? => on each requirement

=> returns the consumables to be created with the order, for each requirement.

=> those consumables are added to the order at creation, and product stocks are derived from that.

## can we know if we can add it to all the sops at the same time, i mean update all the sop's at the same time? 

## but if we reach a sop where it is not sufficient, then 
we will have to have a staged, withdrawal, where that order will not be marked for acceptance, if a sop somewhere down the line could not be handled.

## so after order is added to sop -> what is its state ?
## it will check the transit object and only then schedule it or take it for scheduling.

## now how to have it layered?

## so how to create and update the product stocks.
## basically if the product is consumed, in one place, and 
## created in another, then it will be difficult.

so suppose we create thousands of products.
and then we create a consumable

before order is added to sop -> we have to check for each step if it can be processed, and in doing that 
so if its applicable -> create it.
then check if the requirements are there ->
suppose a requirement is satisfied -> that means we will have to in one operation create all the consumables, inside the sop.
so we can have two states -> 

1. inside the status object -> for each step.
   
1. gather consumables
2. decrementing product counts (here we should store the product ids that need to be decremented, and by how much.)
3. creating consumables.

this is the only way to do all this.

so basically on adding an order what series of steps have to be followed?


1.d
2.b12
3.thyroid
4.axilla
5.edema
6.myasthenia
7.claudication
8.appendix - leucocytosis
9.gall bladder - shoulder_tip pain / clinical exam -> liver functions.
10.cholesterol - signs / symptoms / clinical tests
11.cerebellar function ? copper ? 
12.iron - koilonychia for spoon nails. ( can be done )
--------------------------

lft

kft

iron