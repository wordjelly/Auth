assembly =>
[
	stages => [
		sops => [
			product_ids => [
				
			]
			entry_code => only one entry code, 
			most_probable_exit_code =>  to help the scheduler decide which exit code to pick.
			product_arrays => [
				{
					time_added :
					product_ids_added : [],
					product_ids_removed : []
				}
			],
			steps => [
				step => {
					checked_in : {
						time :
						location :
						actor :
					},
					started : {
						time : 
						location :
						actor :
					},
					ended : {
						time :
						location :
						actor : 
					},
					## or should that be called on update?
					performable_product_ids : [],
					exit_code : can output an exit code, if no exit code, then goes to next step, last step has to have an exit code.
					expected_duration: in mins
					requirements: [
						requirement: {
							state_definition: {

							},
							outputs: [
								{

								}
							],
							requirement_reference_id :	
						}
					],
					instructions: [
						## all instructions have to be given considering multiple numbers of the 
						{
							pool requirement 1
							pool requirement 2.
							mix
						}
					],
					process_step : function(args(hash with any varibles needed to do this step, or the generic hash of variables passed in.)) -> 

					basically just compare states for every single requirement, vis-a-vis its previous requirement id.

					what if we want to do something with some other variables?
				}
			]
		]
	]
]



------------------------------------------------------------


cart_items =>

--------------------------------------------------------------
transit_object => keeps a track of all the states

1> clone the assembly -> if its not already cloned -> how to decide if to clone a new assembly ? or add to another existing assembly ? -> ok for now we clone -
before cloning assembly, we have to search -> if another assembly is ongoing, then its ok, otherwise, 

-- where will we keep the cart_items.?
-- 

2> arguments : {:product_ids => [], assembly_id => },        method_to_call : get_applicable_sops, object_class: assembly., object_id : from step(1) 

for each sop, generated from step 2.

3> arguments : {assembly_id => , :product_ids => []}, method_to_call : create_orders, object_class : sop, object_id : sop_id, while doing this a map will have to maintained, for every product, whether or not an sop is ever going to be hit which has this product id applicable to it?

if the answer is no for any product -> then an event will have to pushed, which will do the flow step defined below.
if the answer is yes, we can wait for that sop to be triggered to see if flow step needs to be done or not.

Flow:

start from the first sop that is applicable to the product.
are the sample requirements satisfied ?
	- no -> the previous sop -> go there and schedule from there.
	- yes -> go to next sop.



- so basically order has to be 

4> suppose that sop status is :

   - so i have an array of applicable sop's with the product ids's to which they are applicable.
   - now i want to know whethere i need to branch from a particular sop - which could be the very beginning or anywhere thereof.
   - it just adds the orders
   - now the next job is also added simultaneously
   - the initial state of the order is just nothing.
   - now what will it do?
   - start from the back ? 
   - let's say a particular sop is running.
   - it picks up all the orders, and checks sample requirements , if they don't get satisfied, it will run upto whatever it ould do.
   - the first time an order is picked up, and not satisifed, it should then be attempted in a branch concept.
   - so assume an order sample requirements are not satisfied.
   - in that case, create an event, where -> it is going to search all the applicable prior sops, for a point where the sample requirements are applicable, and schedule it from there onwards.
   - so it will have to go over each sop, till the point where it is not applicable and consider the previous one.
   - scheduling events are then created for making the schedules on those sop's for that order.
   - finally, when the order is scheduled, at that time the product amounts are minused.
   - what else remains here ? 
   - product provisioning.
   - how to mark sop as done, step as done,
   - how to add images


--------------------------------------------------------------

clones assembly =>

search for those sops which are applicable to the product_ids => 

now build an order object =>

now create it into the first applicable sop => 

validates that the sop can process it =>

calls method process_step =>

calls sufficient? => on each requirement

=> returns the consumables to be created with the order, for each requirement.

=> those consumables are added to the order at creation, and product stocks are derived from that.

## can we know if we can add it to all the sops at the same time, i mean update all the sop's at the same time? 

## but if we reach a sop where it is not sufficient, then 
we will have to have a staged, withdrawal, where that order will not be marked for acceptance, if a sop somewhere down the line could not be handled.

## so after order is added to sop -> what is its state ?
## it will check the transit object and only then schedule it or take it for scheduling.

## now how to have it layered?

## so how to create and update the product stocks.
## basically if the product is consumed, in one place, and 
## created in another, then it will be difficult.

so suppose we create thousands of products.
and then we create a consumable

before order is added to sop -> we have to check for each step if it can be processed, and in doing that 
so if its applicable -> create it.
then check if the requirements are there ->
suppose a requirement is satisfied -> that means we will have to in one operation create all the consumables, inside the sop.
so we can have two states -> 

1. inside the status object -> for each step.
   
1. gather consumables
2. decrementing product counts (here we should store the product ids that need to be decremented, and by how much.)
3. creating consumables.

this is the only way to do all this.

so basically on adding an order what series of steps have to be followed?


1.d
2.b12
3.thyroid
4.axilla
5.edema
6.myasthenia
7.claudication
8.appendix - leucocytosis
9.gall bladder - shoulder_tip pain / clinical exam -> liver functions.
10.cholesterol - signs / symptoms / clinical tests
11.cerebellar function ? copper ? 
12.iron - koilonychia for spoon nails. ( can be done )
--------------------------

lft

kft

iron