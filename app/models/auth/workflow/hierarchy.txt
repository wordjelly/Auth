assembly =>
[
	stages => [
		sops => [
			product_ids => [
				
			]
			entry_code => only one entry code, 
			most_probable_exit_code =>  to help the scheduler decide which exit code to pick.
			product_arrays => [
				{
					time_added :
					product_ids_added : [],
					product_ids_removed : []
				}
			],
			steps => [
				step => {
					checked_in : {
						time :
						location :
						actor :
					},
					started : {
						time : 
						location :
						actor :
					},
					ended : {
						time :
						location :
						actor : 
					},
					## or should that be called on update?
					performable_product_ids : [],
					exit_code : can output an exit code, if no exit code, then goes to next step, last step has to have an exit code.
					expected_duration: in mins
					requirements: [
						requirement: {
							state_definition: {

							},
							outputs: [
								{

								}
							],
							requirement_reference_id :	
						}
					],
					instructions: [
						## all instructions have to be given considering multiple numbers of the 
						{
							pool requirement 1
							pool requirement 2.
							mix
						}
					],
					process_step : function(args(hash with any varibles needed to do this step, or the generic hash of variables passed in.)) -> 

					basically just compare states for every single requirement, vis-a-vis its previous requirement id.

					what if we want to do something with some other variables?
				}
			]
		]
	]
]



------------------------------------------------------------


cart_items =>

--------------------------------------------------------------
transit_object => keeps a track of all the states

1> searching for applicable_sops -> if completed, then should have the applicable sops here, otherwise will go back to that.

2> adding to applicable_sops -> after adding to each sop should note success/failure.

3> 
--------------------------------------------------------------

clones assembly =>

search for those sops which are applicable to the product_ids => 

now build an order object =>

now create it into the first applicable sop => 

validates that the sop can process it =>

calls method process_step =>

calls sufficient? => on each requirement

=> returns the consumables to be created with the order, for each requirement.

=> those consumables are added to the order at creation, and product stocks are derived from that.

## can we know if we can add it to all the sops at the same time, i mean update all the sop's at the same time? 

## but if we reach a sop where it is not sufficient, then 
we will have to have a staged, withdrawal, where that order will not be marked for acceptance, if a sop somewhere down the line could not be handled.

## so after order is added to sop -> what is its state ?
## it will check the transit object and only then schedule it or take it for scheduling.

## now how to have it layered?
